<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cgs_lda.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cgs_lda.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains a GraphLab based implementation of the Collapsed Gibbs Sampler (CGS) for the Latent Dirichlet Allocation (LDA) model.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;graphlab/ui/mongoose/mongoose.h&gt;</code><br />
<code>#include &lt;boost/math/special_functions/gamma.hpp&gt;</code><br />
<code>#include &lt;boost/config/warning_disable.hpp&gt;</code><br />
<code>#include &lt;boost/spirit/include/qi.hpp&gt;</code><br />
<code>#include &lt;boost/spirit/include/phoenix_core.hpp&gt;</code><br />
<code>#include &lt;boost/spirit/include/phoenix_operator.hpp&gt;</code><br />
<code>#include &lt;boost/spirit/include/phoenix_stl.hpp&gt;</code><br />
<code>#include &lt;graphlab/parallel/atomic.hpp&gt;</code><br />
<code>#include &lt;graphlab.hpp&gt;</code><br />
<code>#include &lt;graphlab/macros_def.hpp&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cgs_lda.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="cgs__lda_8cpp__incl.png" border="0" usemap="#cgs__lda_8cpp" alt=""/></div>
<map name="cgs__lda_8cpp" id="cgs__lda_8cpp">
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtop__words__type.html">top_words_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The json top word struct contains the current set of top words for each topic encoded in the form of a json string.  <a href="structtop__words__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvertex__data.html">vertex_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex data represents each term and document in the corpus and contains the counts of tokens in each topic.  <a href="structvertex__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structedge__data.html">edge_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge data represents the individual tokens (word,doc) pairs and their assignment to topics.  <a href="structedge__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgather__type.html">gather_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gather type for the collapsed Gibbs sampler is used to collect the topic counts on adjacent edges so that the apply function can compute the correct topic counts for the center vertex.  <a href="structgather__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgs__lda__vertex__program.html">cgs_lda_vertex_program</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collapsed Gibbs sampler vertex program updates the topic counts for the center vertex and then draws new topic assignments for each edge durring the scatter phase.  <a href="classcgs__lda__vertex__program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtopk__aggregator.html">topk_aggregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The topk aggregator is used to periodically compute and display the topk most common words in each topic.  <a href="classtopk__aggregator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglobal__counts__aggregator.html">global_counts_aggregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global counts aggregator computes the total number of tokens in each topic across all words and documents and then updates the <a class="el" href="cgs__lda_8cpp.html#a068eb66e04ec463ba844fb0ab6d3f433">GLOBAL_TOPIC_COUNT</a> variable.  <a href="structglobal__counts__aggregator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlog__gamma.html">log_gamma</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlikelihood__aggregator.html">likelihood_aggregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Likelihood aggregators maintains the current estimate of the log-likelihood of the current token assignments.  <a href="classlikelihood__aggregator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsignal__only.html">signal_only</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The selective signal functions are used to signal only the vertices corresponding to words or documents. This is done by using the iengine::map_reduce_vertices function.  <a href="structsignal__only.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcount__saver.html">count_saver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac1d787b670f640c8247c9335623d89c3"><td class="memItemLeft" align="right" valign="top"><a id="ac1d787b670f640c8247c9335623d89c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NULL_TOPIC</b>&#160;&#160;&#160;(<a class="el" href="cgs__lda_8cpp.html#a59e02ce4dbef7255967e4afa8d068682">topic_id_type</a>(-1))</td></tr>
<tr class="separator:ac1d787b670f640c8247c9335623d89c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acfaf4c6be82403469aaf1ec860d363e7"><td class="memItemLeft" align="right" valign="top"><a id="acfaf4c6be82403469aaf1ec860d363e7"></a>
typedef long&#160;</td><td class="memItemRight" valign="bottom"><b>count_type</b></td></tr>
<tr class="separator:acfaf4c6be82403469aaf1ec860d363e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eb12558c1c8d8a770e41a8e900807f"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; graphlab::atomic&lt; count_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a01eb12558c1c8d8a770e41a8e900807f">factor_type</a></td></tr>
<tr class="memdesc:a01eb12558c1c8d8a770e41a8e900807f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factor type is used to store the counts of tokens in each topic for words, documents, and assignments.  <a href="#a01eb12558c1c8d8a770e41a8e900807f">More...</a><br /></td></tr>
<tr class="separator:a01eb12558c1c8d8a770e41a8e900807f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e02ce4dbef7255967e4afa8d068682"><td class="memItemLeft" align="right" valign="top"><a id="a59e02ce4dbef7255967e4afa8d068682"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a59e02ce4dbef7255967e4afa8d068682">topic_id_type</a></td></tr>
<tr class="memdesc:a59e02ce4dbef7255967e4afa8d068682"><td class="mdescLeft">&#160;</td><td class="mdescRight">The latent topic id of a token is the smallest reasonable type. <br /></td></tr>
<tr class="separator:a59e02ce4dbef7255967e4afa8d068682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45152c4e5606bd9f54d9c106b4bf8e2"><td class="memItemLeft" align="right" valign="top"><a id="ab45152c4e5606bd9f54d9c106b4bf8e2"></a>
typedef std::vector&lt; <a class="el" href="cgs__lda_8cpp.html#a59e02ce4dbef7255967e4afa8d068682">topic_id_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#ab45152c4e5606bd9f54d9c106b4bf8e2">assignment_type</a></td></tr>
<tr class="memdesc:ab45152c4e5606bd9f54d9c106b4bf8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment type is used on each edge to store the assignments of each token. There can be several occurrences of the same word in a given document and so a vector is used to store the assignments of each occurrence. <br /></td></tr>
<tr class="separator:ab45152c4e5606bd9f54d9c106b4bf8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cfd2cad1698282b6c7fd7f7e7fd459"><td class="memItemLeft" align="right" valign="top">typedef graphlab::distributed_graph&lt; <a class="el" href="structvertex__data.html">vertex_data</a>, <a class="el" href="structedge__data.html">edge_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#ab9cfd2cad1698282b6c7fd7f7e7fd459">graph_type</a></td></tr>
<tr class="memdesc:ab9cfd2cad1698282b6c7fd7f7e7fd459"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LDA graph is a bipartite graph with docs connected to terms if the term occurs in the document.  <a href="#ab9cfd2cad1698282b6c7fd7f7e7fd459">More...</a><br /></td></tr>
<tr class="separator:ab9cfd2cad1698282b6c7fd7f7e7fd459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016cad045fa678bff0a04d795ef3899c"><td class="memItemLeft" align="right" valign="top"><a id="a016cad045fa678bff0a04d795ef3899c"></a>
typedef cgs_lda_vertex_program::icontext_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a016cad045fa678bff0a04d795ef3899c">icontext_type</a></td></tr>
<tr class="memdesc:a016cad045fa678bff0a04d795ef3899c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The icontext type associated with the cgs_lda_vertex program is needed for all aggregators. <br /></td></tr>
<tr class="separator:a016cad045fa678bff0a04d795ef3899c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e712bf0143b71f0f1676078e3351267"><td class="memItemLeft" align="right" valign="top"><a id="a5e712bf0143b71f0f1676078e3351267"></a>
typedef graphlab::omni_engine&lt; <a class="el" href="classcgs__lda__vertex__program.html">cgs_lda_vertex_program</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a5e712bf0143b71f0f1676078e3351267">engine_type</a></td></tr>
<tr class="memdesc:a5e712bf0143b71f0f1676078e3351267"><td class="mdescLeft">&#160;</td><td class="mdescRight">The omni engine type is used to allow switching between synchronous and asynchronous computation. <br /></td></tr>
<tr class="separator:a5e712bf0143b71f0f1676078e3351267"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a028a2c00c268238d3eb378f3b00077a9"><td class="memItemLeft" align="right" valign="top"><a id="a028a2c00c268238d3eb378f3b00077a9"></a>
<a class="el" href="cgs__lda_8cpp.html#a01eb12558c1c8d8a770e41a8e900807f">factor_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a028a2c00c268238d3eb378f3b00077a9">operator+=</a> (<a class="el" href="cgs__lda_8cpp.html#a01eb12558c1c8d8a770e41a8e900807f">factor_type</a> &amp;lvalue, const <a class="el" href="cgs__lda_8cpp.html#a01eb12558c1c8d8a770e41a8e900807f">factor_type</a> &amp;rvalue)</td></tr>
<tr class="memdesc:a028a2c00c268238d3eb378f3b00077a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the factor type in accumulators and so we define an operator+=. <br /></td></tr>
<tr class="separator:a028a2c00c268238d3eb378f3b00077a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa324395e6a36763936cae7b0a13cf496"><td class="memItemLeft" align="right" valign="top"><a id="aa324395e6a36763936cae7b0a13cf496"></a>
std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#aa324395e6a36763936cae7b0a13cf496">word_cloud_callback</a> (std::map&lt; std::string, std::string &gt; &amp;varmap)</td></tr>
<tr class="memdesc:aa324395e6a36763936cae7b0a13cf496"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by the web interface to construct and return the word clouds. <br /></td></tr>
<tr class="separator:aa324395e6a36763936cae7b0a13cf496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fbc8c86d0c2b861a860913b649d229"><td class="memItemLeft" align="right" valign="top"><a id="a17fbc8c86d0c2b861a860913b649d229"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a17fbc8c86d0c2b861a860913b649d229">DECLARE_EVENT</a> (TOKEN_CHANGES)</td></tr>
<tr class="memdesc:a17fbc8c86d0c2b861a860913b649d229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a token changes event tracker which is reported in the GraphLab metrics dashboard. <br /></td></tr>
<tr class="separator:a17fbc8c86d0c2b861a860913b649d229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243a9c69d8720dc113aa4739bf6f80b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a243a9c69d8720dc113aa4739bf6f80b0">eparser</a> (<a class="el" href="structedge__data.html">edge_data</a> &amp;ed, const std::string &amp;line)</td></tr>
<tr class="memdesc:a243a9c69d8720dc113aa4739bf6f80b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge data parser used in graph.load_json.  <a href="#a243a9c69d8720dc113aa4739bf6f80b0">More...</a><br /></td></tr>
<tr class="separator:a243a9c69d8720dc113aa4739bf6f80b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615fd42cf5a6dcca18b986c986e59877"><td class="memItemLeft" align="right" valign="top"><a id="a615fd42cf5a6dcca18b986c986e59877"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a615fd42cf5a6dcca18b986c986e59877">vparser</a> (<a class="el" href="structvertex__data.html">vertex_data</a> &amp;vd, const std::string &amp;line)</td></tr>
<tr class="memdesc:a615fd42cf5a6dcca18b986c986e59877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex data parser used in graph.load_json. <br /></td></tr>
<tr class="separator:a615fd42cf5a6dcca18b986c986e59877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d078ceafcca6f031d16259115c7fd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a77d078ceafcca6f031d16259115c7fd2">graph_loader</a> (<a class="el" href="cgs__lda_8cpp.html#ab9cfd2cad1698282b6c7fd7f7e7fd459">graph_type</a> &amp;graph, const std::string &amp;fname, const std::string &amp;line)</td></tr>
<tr class="memdesc:a77d078ceafcca6f031d16259115c7fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph loader is used by graph.load to parse lines of the text data file.  <a href="#a77d078ceafcca6f031d16259115c7fd2">More...</a><br /></td></tr>
<tr class="separator:a77d078ceafcca6f031d16259115c7fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bddb35493ae7ebf448415f1d87033cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a9bddb35493ae7ebf448415f1d87033cd">is_word</a> (const graph_type::vertex_type &amp;vertex)</td></tr>
<tr class="memdesc:a9bddb35493ae7ebf448415f1d87033cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given vertex is a word vertex or a doc vertex.  <a href="#a9bddb35493ae7ebf448415f1d87033cd">More...</a><br /></td></tr>
<tr class="separator:a9bddb35493ae7ebf448415f1d87033cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aa0fa68b36f6fe444849293a5bfc85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a67aa0fa68b36f6fe444849293a5bfc85">is_doc</a> (const graph_type::vertex_type &amp;vertex)</td></tr>
<tr class="memdesc:a67aa0fa68b36f6fe444849293a5bfc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given vertex is a doc vertex.  <a href="#a67aa0fa68b36f6fe444849293a5bfc85">More...</a><br /></td></tr>
<tr class="separator:a67aa0fa68b36f6fe444849293a5bfc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46630a5f6fc7e253c19929561c47af0a"><td class="memItemLeft" align="right" valign="top"><a id="a46630a5f6fc7e253c19929561c47af0a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a46630a5f6fc7e253c19929561c47af0a">count_tokens</a> (const graph_type::edge_type &amp;edge)</td></tr>
<tr class="memdesc:a46630a5f6fc7e253c19929561c47af0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of tokens on a particular edge. <br /></td></tr>
<tr class="separator:a46630a5f6fc7e253c19929561c47af0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bea130f2e725ad12b59c247643f87bd"><td class="memItemLeft" align="right" valign="top"><a id="a6bea130f2e725ad12b59c247643f87bd"></a>
graph_type::vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a6bea130f2e725ad12b59c247643f87bd">get_other_vertex</a> (const graph_type::edge_type &amp;edge, const graph_type::vertex_type &amp;vertex)</td></tr>
<tr class="memdesc:a6bea130f2e725ad12b59c247643f87bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the other vertex in the edge. <br /></td></tr>
<tr class="separator:a6bea130f2e725ad12b59c247643f87bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15539d26c98141af3ba93717cb4a8b0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a15539d26c98141af3ba93717cb4a8b0f">load_and_initialize_graph</a> (graphlab::distributed_control &amp;dc, <a class="el" href="cgs__lda_8cpp.html#ab9cfd2cad1698282b6c7fd7f7e7fd459">graph_type</a> &amp;graph, const std::string &amp;corpus_dir, const std::string &amp;format)</td></tr>
<tr class="memdesc:a15539d26c98141af3ba93717cb4a8b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to load and then initialize the data graph (corpus) from a folder or file.  <a href="#a15539d26c98141af3ba93717cb4a8b0f">More...</a><br /></td></tr>
<tr class="separator:a15539d26c98141af3ba93717cb4a8b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052648dda24f72fb007c708fa37484c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a8052648dda24f72fb007c708fa37484c">load_dictionary</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a8052648dda24f72fb007c708fa37484c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the dictionary global variable from the file containing the terms (one term per line).  <a href="#a8052648dda24f72fb007c708fa37484c">More...</a><br /></td></tr>
<tr class="separator:a8052648dda24f72fb007c708fa37484c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abca75265d47aed1a5aaac8e79f8db623"><td class="memItemLeft" align="right" valign="top"><a id="abca75265d47aed1a5aaac8e79f8db623"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#abca75265d47aed1a5aaac8e79f8db623">ALPHA</a> = 1</td></tr>
<tr class="memdesc:abca75265d47aed1a5aaac8e79f8db623"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alpha parameter determines the sparsity of topics for each document. <br /></td></tr>
<tr class="separator:abca75265d47aed1a5aaac8e79f8db623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84277b28fe008096c4d3dae3c63c21"><td class="memItemLeft" align="right" valign="top"><a id="afc84277b28fe008096c4d3dae3c63c21"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#afc84277b28fe008096c4d3dae3c63c21">BETA</a> = 0.1</td></tr>
<tr class="memdesc:afc84277b28fe008096c4d3dae3c63c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">the Beta parameter determines the sparsity of words in each document. <br /></td></tr>
<tr class="separator:afc84277b28fe008096c4d3dae3c63c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391de415e9dd8f59cc1706bfcfc3246d"><td class="memItemLeft" align="right" valign="top"><a id="a391de415e9dd8f59cc1706bfcfc3246d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a391de415e9dd8f59cc1706bfcfc3246d">NTOPICS</a> = 50</td></tr>
<tr class="memdesc:a391de415e9dd8f59cc1706bfcfc3246d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the total number of topics to uses <br /></td></tr>
<tr class="separator:a391de415e9dd8f59cc1706bfcfc3246d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec172f5d0a608bc32e20e598a9b6294"><td class="memItemLeft" align="right" valign="top"><a id="a4ec172f5d0a608bc32e20e598a9b6294"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a4ec172f5d0a608bc32e20e598a9b6294">NWORDS</a> = 0</td></tr>
<tr class="memdesc:a4ec172f5d0a608bc32e20e598a9b6294"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of words in the dataset. <br /></td></tr>
<tr class="separator:a4ec172f5d0a608bc32e20e598a9b6294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235ea7ba75a620ac6d2a7d823db7beb0"><td class="memItemLeft" align="right" valign="top"><a id="a235ea7ba75a620ac6d2a7d823db7beb0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a235ea7ba75a620ac6d2a7d823db7beb0">NDOCS</a> = 0</td></tr>
<tr class="memdesc:a235ea7ba75a620ac6d2a7d823db7beb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of docs in the dataset. <br /></td></tr>
<tr class="separator:a235ea7ba75a620ac6d2a7d823db7beb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc8009cd88ea76321df76e78c8a8e04"><td class="memItemLeft" align="right" valign="top"><a id="a9cc8009cd88ea76321df76e78c8a8e04"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a9cc8009cd88ea76321df76e78c8a8e04">NTOKENS</a> = 0</td></tr>
<tr class="memdesc:a9cc8009cd88ea76321df76e78c8a8e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of tokens in the corpus. <br /></td></tr>
<tr class="separator:a9cc8009cd88ea76321df76e78c8a8e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2cc9c2cb517e94277ad2cd3e7f5671"><td class="memItemLeft" align="right" valign="top"><a id="aea2cc9c2cb517e94277ad2cd3e7f5671"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#aea2cc9c2cb517e94277ad2cd3e7f5671">TOPK</a> = 5</td></tr>
<tr class="memdesc:aea2cc9c2cb517e94277ad2cd3e7f5671"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of top words to display during execution (from each topic). <br /></td></tr>
<tr class="separator:aea2cc9c2cb517e94277ad2cd3e7f5671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add85e159418687ce46ff60b126cdeeac"><td class="memItemLeft" align="right" valign="top"><a id="add85e159418687ce46ff60b126cdeeac"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#add85e159418687ce46ff60b126cdeeac">INTERVAL</a> = 10</td></tr>
<tr class="memdesc:add85e159418687ce46ff60b126cdeeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interval to display topics during execution. <br /></td></tr>
<tr class="separator:add85e159418687ce46ff60b126cdeeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af758de5066e69a97f357a88d5bb11df4"><td class="memItemLeft" align="right" valign="top"><a id="af758de5066e69a97f357a88d5bb11df4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#af758de5066e69a97f357a88d5bb11df4">LIK_INTERVAL</a> = 5</td></tr>
<tr class="memdesc:af758de5066e69a97f357a88d5bb11df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interval to compute &amp; display the likelihood. <br /></td></tr>
<tr class="separator:af758de5066e69a97f357a88d5bb11df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068eb66e04ec463ba844fb0ab6d3f433"><td class="memItemLeft" align="right" valign="top"><a id="a068eb66e04ec463ba844fb0ab6d3f433"></a>
<a class="el" href="cgs__lda_8cpp.html#a01eb12558c1c8d8a770e41a8e900807f">factor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a068eb66e04ec463ba844fb0ab6d3f433">GLOBAL_TOPIC_COUNT</a></td></tr>
<tr class="memdesc:a068eb66e04ec463ba844fb0ab6d3f433"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global variable storing the global topic count across all machines. This is maintained periodically using aggregation. <br /></td></tr>
<tr class="separator:a068eb66e04ec463ba844fb0ab6d3f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbd6db47fb779a59303713bea948cc9"><td class="memItemLeft" align="right" valign="top"><a id="abcbd6db47fb779a59303713bea948cc9"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#abcbd6db47fb779a59303713bea948cc9">DICTIONARY</a></td></tr>
<tr class="memdesc:abcbd6db47fb779a59303713bea948cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary of words used to print the top words during execution. <br /></td></tr>
<tr class="separator:abcbd6db47fb779a59303713bea948cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cbfe3ad0ca5846636ae21bfeea8683"><td class="memItemLeft" align="right" valign="top"><a id="ad9cbfe3ad0ca5846636ae21bfeea8683"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#ad9cbfe3ad0ca5846636ae21bfeea8683">MAX_COUNT</a> = 100</td></tr>
<tr class="memdesc:ad9cbfe3ad0ca5846636ae21bfeea8683"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum occurences allowed for an individual term-doc pair. (edge data) <br /></td></tr>
<tr class="separator:ad9cbfe3ad0ca5846636ae21bfeea8683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eee62e08240323f37c38415ad095be"><td class="memItemLeft" align="right" valign="top"><a id="a18eee62e08240323f37c38415ad095be"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgs__lda_8cpp.html#a18eee62e08240323f37c38415ad095be">BURNIN</a> = -1</td></tr>
<tr class="memdesc:a18eee62e08240323f37c38415ad095be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time to run until the first sample is taken. If less than zero then the sampler will run indefinitely. <br /></td></tr>
<tr class="separator:a18eee62e08240323f37c38415ad095be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6076630b85adf902dfa9fe15de589c"><td class="memItemLeft" align="right" valign="top"><a id="aac6076630b85adf902dfa9fe15de589c"></a>
struct <a class="el" href="structtop__words__type.html">top_words_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TOP_WORDS</b></td></tr>
<tr class="separator:aac6076630b85adf902dfa9fe15de589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0f211de9ec402bc20dc4265485f2a6"><td class="memItemLeft" align="right" valign="top"><a id="a0d0f211de9ec402bc20dc4265485f2a6"></a>
<a class="el" href="classlog__gamma.html">log_gamma</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALPHA_LGAMMA</b></td></tr>
<tr class="separator:a0d0f211de9ec402bc20dc4265485f2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa280ff06b4aec7beafa9d16542de2592"><td class="memItemLeft" align="right" valign="top"><a id="aa280ff06b4aec7beafa9d16542de2592"></a>
<a class="el" href="classlog__gamma.html">log_gamma</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BETA_LGAMMA</b></td></tr>
<tr class="separator:aa280ff06b4aec7beafa9d16542de2592"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains a GraphLab based implementation of the Collapsed Gibbs Sampler (CGS) for the Latent Dirichlet Allocation (LDA) model. </p>
<dl class="section author"><dt>Author</dt><dd>Joseph Gonzalez, Diana Hu </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a01eb12558c1c8d8a770e41a8e900807f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eb12558c1c8d8a770e41a8e900807f">&#9670;&nbsp;</a></span>factor_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; graphlab::atomic&lt;count_type&gt; &gt; <a class="el" href="cgs__lda_8cpp.html#a01eb12558c1c8d8a770e41a8e900807f">factor_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The factor type is used to store the counts of tokens in each topic for words, documents, and assignments. </p>
<p>Atomic counts are used because we violate the abstraction by modifying adjacent vertex data on scatter. As a consequence multiple threads on the same machine may try to update the same vertex data at the same time. The graphlab::atomic type ensures that multiple increments are serially consistent. </p>

</div>
</div>
<a id="ab9cfd2cad1698282b6c7fd7f7e7fd459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cfd2cad1698282b6c7fd7f7e7fd459">&#9670;&nbsp;</a></span>graph_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef graphlab::distributed_graph&lt;<a class="el" href="structvertex__data.html">vertex_data</a>, <a class="el" href="structedge__data.html">edge_data</a>&gt; <a class="el" href="cgs__lda_8cpp.html#ab9cfd2cad1698282b6c7fd7f7e7fd459">graph_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The LDA graph is a bipartite graph with docs connected to terms if the term occurs in the document. </p>
<p>The edges store the number of occurrences of the term in the document as a vector of the assignments of that term in that document to topics.</p>
<p>The vertices store the total topic counts. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a243a9c69d8720dc113aa4739bf6f80b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243a9c69d8720dc113aa4739bf6f80b0">&#9670;&nbsp;</a></span>eparser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eparser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__data.html">edge_data</a> &amp;&#160;</td>
          <td class="paramname"><em>ed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edge data parser used in graph.load_json. </p>
<p>Make sure that the edge file list has docids from -2 to -(total #docid) and wordids 0 to (total #words -1) </p>

</div>
</div>
<a id="a77d078ceafcca6f031d16259115c7fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d078ceafcca6f031d16259115c7fd2">&#9670;&nbsp;</a></span>graph_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool graph_loader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgs__lda_8cpp.html#ab9cfd2cad1698282b6c7fd7f7e7fd459">graph_type</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The graph loader is used by graph.load to parse lines of the text data file. </p>
<p>The global variable MAX_COUNT limits the number of tokens that can be constructed on a particular edge.</p>
<p>We use the relativley fast boost::spirit parser to parse each line. </p>

</div>
</div>
<a id="a67aa0fa68b36f6fe444849293a5bfc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67aa0fa68b36f6fe444849293a5bfc85">&#9670;&nbsp;</a></span>is_doc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_doc </td>
          <td>(</td>
          <td class="paramtype">const graph_type::vertex_type &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given vertex is a doc vertex. </p>
<p>For simplicity we connect docs &ndash;&gt; words and therefore if a vertex has out edges then it is a doc </p>

</div>
</div>
<a id="a9bddb35493ae7ebf448415f1d87033cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bddb35493ae7ebf448415f1d87033cd">&#9670;&nbsp;</a></span>is_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_word </td>
          <td>(</td>
          <td class="paramtype">const graph_type::vertex_type &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given vertex is a word vertex or a doc vertex. </p>
<p>For simplicity we connect docs &ndash;&gt; words and therefore if a vertex has in edges then it is a word. </p>

</div>
</div>
<a id="a15539d26c98141af3ba93717cb4a8b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15539d26c98141af3ba93717cb4a8b0f">&#9670;&nbsp;</a></span>load_and_initialize_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_and_initialize_graph </td>
          <td>(</td>
          <td class="paramtype">graphlab::distributed_control &amp;&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cgs__lda_8cpp.html#ab9cfd2cad1698282b6c7fd7f7e7fd459">graph_type</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>corpus_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to load and then initialize the data graph (corpus) from a folder or file. </p>
<p>The graph can be in either json form constructed using the graph builder tools or in raw text form. The raw text format contains a token on each line of each file in the format:</p>
<pre class="fragment">&lt;docid&gt; &lt;wordid&gt; &lt;count&gt;
         ...
</pre><p>for example: </p><pre class="fragment">   0    0     2
   0    4     1
   0    2     3
</pre><p>implies that document zero contains word zero twice, word 4 once, and word two three times.</p>
<p>If a dictionary is used it is important that each word id correspond to the index in the dictionary file (starting at zero).</p>
<p>Once loaded the total number of words, documents, and tokens is counted and saved to global variables which are read during the execution of the sampler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dc</td><td>The distributed control object used to coordinate between machines.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">graph</td><td>The graph object that is initialized.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corpus_dir</td><td>The directory or file containing the graph data. The corpus directory can reside on hdfs in which case the path should begin with "hdfs://namenode". In addition the file(s) may be gzipped and therefore must end in ".gz".</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_json</td><td>Whether the graph data is in text format or preprocessed json format using the graph builder tools. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8052648dda24f72fb007c708fa37484c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8052648dda24f72fb007c708fa37484c">&#9670;&nbsp;</a></span>load_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the dictionary global variable from the file containing the terms (one term per line). </p>
<p>Note that while graphs can be loaded from multiple files the dictionary must be in a single file. The dictionary is loaded entirely into memory and used to display word clouds and the top terms in each topic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>the file containing the dictionary data. The data can be located on HDFS and can also be gzipped (must end in ".gz"). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c04138a5bfe5d72780bb7e82a18e627">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>! Initialize control plain using mpi</p>
<p>! Initialize global variables</p>
<p>Initialize the <a class="el" href="classlog__gamma.html">log_gamma</a> precached calculations.</p>
<p>! load the graph</p>
<p>! Add an aggregator</p>
<p>! schedule only documents </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
